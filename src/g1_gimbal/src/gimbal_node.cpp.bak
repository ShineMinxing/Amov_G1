#include <rclcpp/rclcpp.hpp>
#include <std_msgs/msg/string.hpp>
#include "amovGimbal/amov_gimbal.h"
#include "serial/serial.h"
#include <chrono>
#include <sstream>

// ls /dev/tty*
// sudo chmod 777 /dev/ttyUSB0
// gst-launch-1.0 rtspsrc location="rtsp://192.168.2.64:554/H264" protocols=GST_RTSP_LOWER_TRANS_UDP     latency=0 ! rtph264depay ! avdec_h264 ! videoconvert ! autovideosink

// Implementation of the IOStreamBase interface class based on Serial library
class UART : public amovGimbal::IOStreamBase
{
private:
  serial::Serial *ser;

public:
  virtual bool open()
  {
    ser->open();
    return true;
  }
  virtual bool close()
  {
    ser->close();
    return true;
  }
  virtual bool isOpen()
  {
    return ser->isOpen();
  }
  virtual bool isBusy()
  {
    return false;
  }
  virtual uint32_t inPutBytes(IN uint8_t *byte)
  {
    if (ser->read(byte, 1))
    {
      return 1;
    }
    return 0;
  }
  virtual uint32_t outPutBytes(IN uint8_t *byte, uint32_t length)
  {
    return ser->write(byte, length);
  }

  UART(const std::string &port)
  {
    // 设置115200波特率 & 500ms超时
    ser = new serial::Serial(port, 115200, serial::Timeout::simpleTimeout(500));
  }
  ~UART()
  {
    ser->close();
    delete ser;
  }
};

class GimbalNode : public rclcpp::Node
{
public:
  GimbalNode()
    : Node("gimbal_node"), gimbal_state_(0), gimbal_counter_(0)
  {
    // 云台串口与ID初始化
    std::string port = "/dev/ttyUSB0";
    std::string gimbal_id = "G1";

    pub_ = this->create_publisher<std_msgs::msg::String>("SMXFE/Gimbal_State", 10);

    uart_ = std::make_shared<UART>(port);
    gimbal_ = std::make_shared<amovGimbal::gimbal>(gimbal_id, uart_.get());
    gimbal_->startStack();

    // 注册回调，获取云台状态
    auto cb = [](double fr, double fp, double fy,
                 double ir, double ip, double iy,
                 double fx, double fy2, void *caller)
    {
      GimbalNode *node = static_cast<GimbalNode*>(caller);
      if (node) {
        node->onGimbalUpdate(fr, fp, fy, ir, ip, iy, fx, fy2);
      }
    };
    gimbal_->parserAuto(cb, this);

    RCLCPP_INFO(this->get_logger(), "GimbalNode started. port=%s, id=%s",
                port.c_str(), gimbal_id.c_str());

    // 定时器：每秒调用一次，用于云台动作控制（通过计数器实现状态切换）
    timer_ = this->create_wall_timer(std::chrono::seconds(1),
                std::bind(&GimbalNode::timerCallback, this));
  }

private:
  // 云台状态回调：只做输出
  void onGimbalUpdate(double frameRoll, double framePitch, double frameYaw,
                      double imuRoll,   double imuPitch,   double imuYaw,
                      double fovX,      double fovY)
  {
    std_msgs::msg::String msg;
    std::stringstream ss;
    ss << "[Gimbal State]\n"
       << "frameYaw  : " << frameYaw   << "\n"
       << "frameRoll : " << frameRoll  << "\n"
       << "framePitch: " << framePitch << "\n"
       << "imuYaw    : " << imuYaw     << "\n"
       << "imuRoll   : " << imuRoll    << "\n"
       << "imuPitch  : " << imuPitch   << "\n"
       << "fovX      : " << fovX       << "\n"
       << "fovY      : " << fovY;
    msg.data = ss.str();
    pub_->publish(msg);
  }

  // 云台动作控制定时器回调（每秒一次）
  void timerCallback()
  {
    if (gimbal_counter_ == 0) {
      AMOV_GIMBAL_POS_T pos;
      switch (gimbal_state_) {
        case 0:
          pos.yaw   = 10.0f;
          pos.pitch = 45.0f;
          pos.roll  = 0.0f;
          RCLCPP_INFO(this->get_logger(), "State 0: Setting pos A");
          gimbal_->setGimabalPos(pos);
          break;
        case 1:
          pos.yaw   = 0.0f;
          pos.pitch = 45.0f;
          pos.roll  = 0.0f;
          RCLCPP_INFO(this->get_logger(), "State 1: Setting pos B");
          gimbal_->setGimabalPos(pos);
          break;
        case 2:
          pos.yaw   = -10.0f;
          pos.pitch = 45.0f;
          pos.roll  = 0.0f;
          RCLCPP_INFO(this->get_logger(), "State 2: Setting pos C");
          gimbal_->setGimabalPos(pos);
          break;
        case 3:
          pos.yaw   = 0.0f;
          pos.pitch = 45.0f;
          pos.roll  = 0.0f;
          RCLCPP_INFO(this->get_logger(), "State 3: Setting pos D");
          gimbal_->setGimabalPos(pos);
          break;
        default:
          break;
      }
    }
    gimbal_counter_++;

    // 状态持续时间
    switch (gimbal_state_) {
      case 0:
        if (gimbal_counter_ >= 10) {
          gimbal_counter_ = 0;
          gimbal_state_ = 1;
        }
        break;
      case 1:
        if (gimbal_counter_ >= 1) {
          gimbal_counter_ = 0;
          gimbal_state_ = 2;
        }
        break;
      case 2:
        if (gimbal_counter_ >= 10) {
          gimbal_counter_ = 0;
          gimbal_state_ = 3;
        }
        break;
      case 3:
        if (gimbal_counter_ >= 1) {
          gimbal_counter_ = 0;
          gimbal_state_ = 0;
        }
        break;
      default:
        break;
    }
  }

  rclcpp::Publisher<std_msgs::msg::String>::SharedPtr pub_;
  std::shared_ptr<UART> uart_;
  std::shared_ptr<amovGimbal::gimbal> gimbal_;
  rclcpp::TimerBase::SharedPtr timer_;

  int gimbal_state_{0};
  int gimbal_counter_{0};
};

int main(int argc, char *argv[])
{
  rclcpp::init(argc, argv);
  auto node = std::make_shared<GimbalNode>();
  rclcpp::spin(node);
  rclcpp::shutdown();
  return 0;
}
